import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Load the data
df = pd.read_csv("Bond_Yield.csv", index_col="Dates")

# Get all yield columns
yield_columns = df.columns

# Generate all possible pairs
pairs = [(col1, col2) for i, col1 in enumerate(yield_columns) for col2 in yield_columns[i+1:]]

# Function to calculate Z-score
def calculate_z_score(series, window=10):
    rolling_mean = series.rolling(window=window).mean()
    rolling_std = series.rolling(window=window).std()
    z_score = (series - rolling_mean) / rolling_std
    return z_score

# Calculate spreads and Z-scores for each pair
results = {}
for pair in pairs:
    spread = df[pair[1]] - df[pair[0]]  # Longer maturity - shorter maturity
    z_score = calculate_z_score(spread)
    results[pair] = z_score

# Plotting all Z-scores
plt.figure(figsize=(15, 10))
for i, (pair, z_score) in enumerate(results.items(), 1):
    plt.subplot(6, 6, i)
    plt.plot(df.index, z_score, label=f"{pair[0]}-{pair[1]}")
    plt.title(f"{pair[0]}-{pair[1]} Z-Score")
    plt.legend()
    plt.xticks(rotation=45)
    if i % 6 != 1:  # Avoid duplicating y-axis labels
        plt.gca().set_yticklabels([])
    plt.grid(True)

plt.tight_layout()
plt.show()








# Step 1: compute window-based stats dynamically
window_stats_df = compute_spread_stats_window(df, target_date="2023-11-23", days_before=200, days_after=200)

# Step 2: Convert to dict for easy access
spread_stats = {
    tenor.replace("Spread_", "").replace("M", ""): {
        "median": window_stats_df.loc[tenor, 'median'],
        "std": window_stats_df.loc[tenor, 'std_dev']
    }
    for tenor in window_stats_df.index
}


# Step 3: Calculate pricing score columns
for m in range(1, 7):
    cb_col = f'CB_Zero_Spot_{m}M'
    ois_col = f'{m}M'
    spread_info = spread_stats[str(m)]
    
    fair_val = df[cb_col] + spread_info['median']
    score = (df[ois_col] - fair_val) / spread_info['std']
    df[f'Pricing_Score_{m}M'] = score


# -------------------------------------
# STEP 3: Plot Pricing Score Grid
# -------------------------------------
def plot_pricing_score_grid(df, target_date, days_before=200, days_after=200):
    import matplotlib.pyplot as plt
    import seaborn as sns

    # Filter
    df['Dates'] = pd.to_datetime(df['Dates'])
    target_date = pd.to_datetime(target_date)
    df_window = df[(df['Dates'] >= target_date - pd.Timedelta(days=days_before)) & 
                   (df['Dates'] <= target_date + pd.Timedelta(days=days_after))]

    # Set up grid
    fig, axes = plt.subplots(3, 2, figsize=(16, 12), sharex=True)
    axes = axes.flatten()

    for idx, m in enumerate(range(1, 7)):
        col = f'Pricing_Score_{m}M'
        sns.lineplot(x='Dates', y=col, data=df_window, ax=axes[idx], label=f'{m}M Score', color='darkblue')
        axes[idx].axhline(0, color='black', linestyle='--', linewidth=1)
        axes[idx].axhline(1, color='green', linestyle='--', linewidth=1, label='+1 std')
        axes[idx].axhline(-1, color='red', linestyle='--', linewidth=1, label='-1 std')
        axes[idx].set_title(f'Pricing Score: {m}M')
        axes[idx].legend()

        # Plot MPC dates
        for d in mpc_dates:
            if df_window['Dates'].min() <= d <= df_window['Dates'].max():
                axes[idx].axvline(d, color='purple', linestyle=':', linewidth=1)

    plt.tight_layout()
    plt.show()


plot_pricing_score_grid(df, target_date="2023-11-23", days_before=200, days_after=200)










for m in range(1, 7):
    spread_col = f'Spread_{m}M'
    z_col = f'Rolling_Z_{m}M'
    MA_col = f'MA_{m}M'
    df[z_col] = (df[spread_col] - df[spread_col].rolling(window=60).mean()) / \
                df[spread_col].rolling(window=60).std()
    df[MA_col] = df[spread_col].rolling(window=60).mean()










for m in range(1, 7):
    df[f'Spread_{m}M'] = df[f'Fwd_OIS_after_{m}M'] - df[f'CB_Zero_Spot_{m}M']


spread_stats = {}

for m in range(1, 7):
    spread_col = f'Spread_{m}M'
    stats = df[spread_col].describe()
    stats['median'] = df[spread_col].median()
    stats['std_dev'] = df[spread_col].std()
    stats['skew'] = df[spread_col].skew()
    stats['kurtosis'] = df[spread_col].kurt()
    spread_stats[spread_col] = stats

# Convert to DataFrame for display
spread_stats_df = pd.DataFrame(spread_stats)
print(spread_stats_df.T)



import matplotlib.pyplot as plt
import seaborn as sns
sns.set(style="whitegrid")

def plot_spread_grid(df, mpc_dates, target_date, days_before=200, days_after=200):
    df['Dates'] = pd.to_datetime(df['Dates'])
    target_date = pd.to_datetime(target_date)
    start = target_date - pd.Timedelta(days=days_before)
    end = target_date + pd.Timedelta(days=days_after)

    df_sub = df[(df['Dates'] >= start) & (df['Dates'] <= end)].copy()
    
    fig, axs = plt.subplots(3, 2, figsize=(15, 10), sharex=True)
    axs = axs.flatten()

    for idx, m in enumerate(range(1, 7)):
        col = f'Spread_{m}M'
        ax = axs[idx]
        z_col = f'Rolling_Z_{m}M'
        sns.lineplot(data=df_sub, x='Dates', y=col, ax=ax)
        sns.lineplot(data=df_sub, x='Dates', y='Spread_3M', label='Spread_3M')
        sns.lineplot(data=df_sub, x='Dates', y=z_col, label='60D MA')
        ax.set_title(f'Spread {m}M: OIS - CB_Zero')
        ax.axvline(target_date, color='black', linestyle='-', label='Target Date')

        for mpc_date in mpc_dates:
            if start <= mpc_date <= end:
                ax.axvline(mpc_date, color='red', linestyle='--', alpha=0.6)

        ax.legend()
        ax.grid(True)

    plt.tight_layout()
    plt.show()



plot_spread_grid(df, mpc_dates, target_date="2023-11-23")





from datetime import timedelta

def compute_spread_stats_window(df, target_date, days_before=200, days_after=200):
    df['Dates'] = pd.to_datetime(df['Dates'])
    target_date = pd.to_datetime(target_date)
    start = target_date - pd.Timedelta(days=days_before)
    end = target_date + pd.Timedelta(days=days_after)

    df_window = df[(df['Dates'] >= start) & (df['Dates'] <= end)].copy()

    spread_stats = {}
    for m in range(1, 7):
        spread_col = f'Spread_{m}M'
        series = df_window[spread_col].dropna()
        stats = series.describe()
        stats['median'] = series.median()
        stats['std_dev'] = series.std()
        stats['skew'] = series.skew()
        stats['kurtosis'] = series.kurt()
        spread_stats[spread_col] = stats

    return pd.DataFrame(spread_stats).T




stats_around_date = compute_spread_stats_window(df, target_date="2023-11-23", days_before=200, days_after=200)
print(stats_around_date)
